// RAGbox.co - Prisma Schema
// PostgreSQL with pgvector extension for embeddings

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
  binaryTargets   = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [vector]
}

// ============================================
// User & Authentication
// ============================================

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  image     String?
  role      user_role @default(Associate)
  status    user_status @default(Active)
  privilegeModeEnabled Boolean @default(false) @map("privilege_mode_enabled")
  privilegeModeChangedAt DateTime? @map("privilege_mode_changed_at")
  createdAt DateTime @default(now()) @map("created_at")
  lastLoginAt DateTime? @map("last_login_at")

  // Relations
  vaults    Vault[]
  documents Document[]
  queries   Query[]
  auditLogs AuditLog[]
  folders   Folder[]
  templates Template[]
  learningSessions LearningSession[]
  contentGaps      ContentGap[]
  whatsappContacts      WhatsAppContact[]
  whatsappConversations WhatsAppConversation[]
  integrationSettings   IntegrationSettings?

  @@map("users")
}

enum user_role {
  Partner
  Associate
  Auditor
}

enum user_status {
  Active
  Suspended
}

// ============================================
// Vault (Document Container)
// ============================================

model Vault {
  id               String   @id @default(cuid())
  name             String
  userId           String   @map("user_id")
  status           vault_status @default(open)
  documentCount    Int      @default(0) @map("document_count")
  storageUsedBytes BigInt   @default(0) @map("storage_used_bytes")
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")

  // Relations
  user         User              @relation(fields: [userId], references: [id])
  documents    Document[]
  learningSessions LearningSession[]
  healthChecks     KBHealthCheck[]

  @@map("vaults")
}

enum vault_status {
  open
  closed
  secure
}

// ============================================
// Document
// ============================================

model Document {
  id              String         @id @default(cuid())
  vaultId         String?        @map("vault_id")
  userId          String         @map("user_id")
  filename        String
  originalName    String         @map("original_name")
  mimeType        String         @map("mime_type")
  fileType        String         @map("file_type")
  sizeBytes       Int            @map("size_bytes")
  storageUri      String?        @map("storage_uri")
  storagePath     String?        @map("storage_path")
  extractedText   String?        @map("extracted_text")
  indexStatus     index_status    @default(Pending) @map("index_status")
  deletionStatus  deletion_status @default(Active) @map("deletion_status")
  isPrivileged    Boolean        @default(false) @map("is_privileged")
  securityTier    Int            @default(0) @map("security_tier")
  chunkCount      Int            @default(0) @map("chunk_count")
  checksum        String?
  folderId        String?        @map("folder_id")
  metadata        Json?
  deletedAt       DateTime?      @map("deleted_at")
  hardDeleteAt    DateTime?      @map("hard_delete_at")
  createdAt       DateTime       @default(now()) @map("created_at")
  updatedAt       DateTime       @updatedAt @map("updated_at")

  // Relations
  vault    Vault?          @relation(fields: [vaultId], references: [id])
  user     User            @relation(fields: [userId], references: [id])
  folder   Folder?         @relation(fields: [folderId], references: [id])
  chunks   DocumentChunk[]
  citations Citation[]

  @@index([userId, deletionStatus])
  @@index([vaultId])
  @@index([securityTier])
  @@index([folderId])
  @@map("documents")
}

enum index_status {
  Pending
  Processing
  Indexed
  Failed
}

enum deletion_status {
  Active
  SoftDeleted
  HardDeleted
}

// ============================================
// Document Chunk (with pgvector embedding)
// ============================================

model DocumentChunk {
  id          String   @id @default(cuid())
  documentId  String   @map("document_id")
  chunkIndex  Int      @map("chunk_index")
  content     String
  contentHash String   @map("content_hash")
  tokenCount  Int      @default(0) @map("token_count")
  embedding   Unsupported("vector(768)")?
  createdAt   DateTime @default(now()) @map("created_at")

  // Relations
  document  Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)
  citations Citation[]

  @@index([documentId])
  @@map("document_chunks")
}

// ============================================
// Query & Answer
// ============================================

model Query {
  id              String       @id @default(cuid())
  userId          String       @map("user_id")
  queryText       String       @map("query_text")
  confidenceScore Float?       @map("confidence_score")
  outcome         query_outcome @default(Answered)
  privilegeMode   Boolean      @default(false) @map("privilege_mode")
  chunksUsed      Int          @default(0) @map("chunks_used")
  latencyMs       Int?         @map("latency_ms")
  model           String?
  createdAt       DateTime     @default(now()) @map("created_at")

  // Relations
  user    User     @relation(fields: [userId], references: [id])
  answer  Answer?

  @@index([userId])
  @@map("queries")
}

enum query_outcome {
  Answered
  Refused
}

model Answer {
  id         String   @id @default(cuid())
  queryId    String   @unique @map("query_id")
  answerText String   @map("answer_text")
  createdAt  DateTime @default(now()) @map("created_at")

  // Relations
  query     Query     @relation(fields: [queryId], references: [id], onDelete: Cascade)
  citations Citation[]

  @@map("answers")
}

// ============================================
// Citation
// ============================================

model Citation {
  id             String @id @default(cuid())
  answerId       String @map("answer_id")
  documentId     String @map("document_id")
  chunkId        String? @map("chunk_id")
  relevanceScore Float  @map("relevance_score")
  excerpt        String?
  citationIndex  Int    @map("citation_index")

  // Relations
  answer   Answer        @relation(fields: [answerId], references: [id], onDelete: Cascade)
  document Document      @relation(fields: [documentId], references: [id])
  chunk    DocumentChunk? @relation(fields: [chunkId], references: [id])

  @@map("citations")
}

// ============================================
// Audit Log
// ============================================

model AuditLog {
  id           String   @id @default(cuid())
  userId       String?  @map("user_id")
  action       String
  resourceId   String?  @map("resource_id")
  resourceType String?  @map("resource_type")
  severity     String   @default("INFO")
  details      Json?
  detailsHash  String?  @map("details_hash")
  ipAddress    String?  @map("ip_address")
  userAgent    String?  @map("user_agent")
  createdAt    DateTime @default(now()) @map("created_at")

  // Relations
  user User? @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

// ============================================
// Folder (for Drop Zone file explorer)
// ============================================

model Folder {
  id        String   @id @default(cuid())
  name      String
  userId    String   @map("user_id")
  parentId  String?  @map("parent_id")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  user      User       @relation(fields: [userId], references: [id])
  parent    Folder?    @relation("FolderTree", fields: [parentId], references: [id])
  children  Folder[]   @relation("FolderTree")
  documents Document[]

  @@index([userId])
  @@index([parentId])
  @@map("folders")
}

// ============================================
// Template (FORGE system)
// ============================================

model Template {
  id          String   @id @default(cuid())
  name        String
  description String?
  userId      String   @default("system") @map("user_id")
  category    String?
  sections    Json?    // Template section definitions
  fields      Json?    // Template field definitions
  structure   Json?    // Document structure analysis
  confidence  Float?   @default(0.5) // Analysis confidence score
  sourceFile  String?  @map("source_file")
  storageUri  String?  @map("storage_uri")
  thumbnail   String?
  usageCount  Int      @default(0) @map("usage_count")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  user User @relation(fields: [userId], references: [id])

  @@index([userId])
  @@map("templates")
}

// ============================================
// Learning Session (Content Intelligence)
// ============================================

model LearningSession {
  id               String          @id @default(cuid())
  userId           String          @map("user_id")
  vaultId          String          @map("vault_id")
  status           session_status  @default(active)
  topicsCovered    Json            @default("[]") @map("topics_covered")
  documentsQueried Json            @default("[]") @map("documents_queried")
  queryCount       Int             @default(0) @map("query_count")
  totalDurationMs  BigInt          @default(0) @map("total_duration_ms")
  createdAt        DateTime        @default(now()) @map("created_at")
  updatedAt        DateTime        @updatedAt @map("updated_at")

  // Relations
  user  User  @relation(fields: [userId], references: [id])
  vault Vault @relation(fields: [vaultId], references: [id])

  @@index([userId, status])
  @@index([vaultId])
  @@map("learning_sessions")
}

enum session_status {
  active
  paused
  completed
}

// ============================================
// Content Gap (Content Intelligence)
// ============================================

model ContentGap {
  id              String          @id @default(cuid())
  userId          String          @map("user_id")
  queryText       String          @map("query_text")
  confidenceScore Float           @map("confidence_score")
  suggestedTopics String[]        @map("suggested_topics")
  status          gap_status      @default(open)
  addressedAt     DateTime?       @map("addressed_at")
  createdAt       DateTime        @default(now()) @map("created_at")

  // Relations
  user User @relation(fields: [userId], references: [id])

  @@index([userId, status])
  @@map("content_gaps")
}

enum gap_status {
  open
  addressed
  dismissed
}

// ============================================
// KB Health Check (Content Intelligence)
// ============================================

model KBHealthCheck {
  id        String          @id @default(cuid())
  vaultId   String          @map("vault_id")
  checkType String          @map("check_type")
  status    health_status
  details   Json?
  runAt     DateTime        @default(now()) @map("run_at")

  // Relations
  vault Vault @relation(fields: [vaultId], references: [id])

  @@index([vaultId, checkType])
  @@map("kb_health_checks")
}

enum health_status {
  passed
  warning
  failed
}

// ============================================
// WhatsApp Integration
// ============================================

model WhatsAppContact {
  id           String   @id @default(cuid())
  userId       String   @map("user_id")
  phoneNumber  String   @map("phone_number") // E.164 format
  displayName  String?  @map("display_name")
  isBlocked    Boolean  @default(false) @map("is_blocked")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  // Relations
  user          User                  @relation(fields: [userId], references: [id])
  conversations WhatsAppConversation[]

  @@unique([userId, phoneNumber])
  @@index([userId])
  @@map("whatsapp_contacts")
}

model WhatsAppConversation {
  id              String                    @id @default(cuid())
  userId          String                    @map("user_id")
  contactId       String                    @map("contact_id")
  status          wa_conversation_status    @default(active)
  autoReply       Boolean                   @default(true) @map("auto_reply")
  unreadCount     Int                       @default(0) @map("unread_count")
  lastMessageText String?                   @map("last_message_text")
  lastMessageAt   DateTime?                 @map("last_message_at")
  createdAt       DateTime                  @default(now()) @map("created_at")
  updatedAt       DateTime                  @updatedAt @map("updated_at")

  // Relations
  user     User             @relation(fields: [userId], references: [id])
  contact  WhatsAppContact  @relation(fields: [contactId], references: [id])
  messages WhatsAppMessage[]

  @@unique([userId, contactId])
  @@index([userId, lastMessageAt(sort: Desc)])
  @@map("whatsapp_conversations")
}

model WhatsAppMessage {
  id                 String              @id @default(cuid())
  conversationId     String              @map("conversation_id")
  externalMessageId  String?             @map("external_message_id")
  direction          wa_direction
  messageType        wa_message_type     @default(text) @map("message_type")
  content            String?
  mediaUrl           String?             @map("media_url")
  status             wa_message_status   @default(sent)
  confidence         Float?              // RAG confidence for auto-replies
  queryId            String?             @map("query_id") // Link to RAG query
  createdAt          DateTime            @default(now()) @map("created_at")

  // Relations
  conversation WhatsAppConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
  @@index([externalMessageId])
  @@map("whatsapp_messages")
}

enum wa_direction {
  inbound
  outbound
}

enum wa_message_type {
  text
  audio
  image
  document
  system
}

enum wa_message_status {
  sent
  delivered
  read
  failed
}

enum wa_conversation_status {
  active
  archived
  blocked
}

// ============================================
// Waitlist (Pioneer Program Signups)
// ============================================

model WaitlistEntry {
  id        String   @id @default(cuid())
  email     String   @unique
  source    String?  // landing, blog, referral, etc.
  referrer  String?
  ipAddress String?  @map("ip_address")
  createdAt DateTime @default(now()) @map("created_at")

  @@map("waitlist_entries")
}

// ============================================
// Integration Settings
// ============================================

model IntegrationSettings {
  id        String   @id @default(cuid())
  userId    String   @unique @map("user_id")

  // WhatsApp
  whatsappEnabled       Boolean  @default(false) @map("whatsapp_enabled")
  whatsappProvider      String   @default("vonage") @map("whatsapp_provider")
  vonageApiKey          String?  @map("vonage_api_key")
  vonageApiSecret       String?  @map("vonage_api_secret")
  vonageApplicationId   String?  @map("vonage_application_id")
  vonageWhatsAppNumber  String?  @map("vonage_whatsapp_number")
  metaAccessToken       String?  @map("meta_access_token")
  metaPhoneNumberId     String?  @map("meta_phone_number_id")
  metaAppSecret         String?  @map("meta_app_secret")

  // Mercury
  mercuryVoiceEnabled   Boolean  @default(true) @map("mercury_voice_enabled")
  mercuryVoiceModel     String   @default("aura-asteria-en") @map("mercury_voice_model")
  mercuryAutoReply      Boolean  @default(true) @map("mercury_auto_reply")

  // Permissions
  whatsappAllowInbound  Boolean  @default(true) @map("whatsapp_allow_inbound")
  whatsappAllowOutbound Boolean  @default(true) @map("whatsapp_allow_outbound")
  whatsappAllowVoiceNotes Boolean @default(true) @map("whatsapp_allow_voice_notes")
  whatsappAllowedNumbers String[] @map("whatsapp_allowed_numbers")
  defaultVaultId        String?  @map("default_vault_id")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("integration_settings")
}
